<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Cardano.Chain.Byron.API</title><link href="https://hackage.haskell.org/package/cardano-ledger-binary-1.3.3.0/docs/Cardano-Ledger-Binary-Decoding.html#t:ByteSpan" title="Cardano.Ledger.Binary.Decoding">ByteSpan</a>)) -&gt; f a -&gt; f <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a></li><li class="src short"><a href="#v:abobMatchesBody">abobMatchesBody</a> :: <a href="Cardano-Chain-Block.html#t:ABlockOrBoundaryHdr" title="Cardano.Chain.Block">ABlockOrBoundaryHdr</a> <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="Cardano-Chain-Block.html#t:ABlockOrBoundary" title="Cardano.Chain.Block">ABlockOrBoundary</a> <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="https://hackage.haskell.org/package/Cabal-syntax-3.10.3.0/docs/Distribution-Compat-Prelude.html#t:Bool" title="Distribution.Compat.Prelude">Bool</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Extract info from chain state</h1></a><div class="top"><p class="src"><a id="v:getDelegationMap" class="def">getDelegationMap</a> :: <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> -&gt; <a href="Cardano-Chain-Delegation.html#t:Map" title="Cardano.Chain.Delegation">Map</a> <a href="#v:getDelegationMap" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:getMaxBlockSize" class="def">getMaxBlockSize</a> :: <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> -&gt; <a href="https://hackage.haskell.org/package/Cabal-syntax-3.10.3.0/docs/Distribution-Compat-Prelude.html#t:Word32" title="Distribution.Compat.Prelude">Word32</a> <a href="#v:getMaxBlockSize" class="selflink">#</a></p></div><a href="#g:2" id="g:2"><h1>Applying blocks</h1></a><div class="top"><p class="src"><a id="v:applyChainTick" class="def">applyChainTick</a> :: <a href="Cardano-Chain-Genesis.html#t:Config" title="Cardano.Chain.Genesis">Config</a> -&gt; <a href="Cardano-Chain-Slotting.html#t:SlotNumber" title="Cardano.Chain.Slotting">SlotNumber</a> -&gt; <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> -&gt; <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> <a href="#v:applyChainTick" class="selflink">#</a></p><div class="doc"><p>Apply chain tick</p><p>This is the part of block processing that depends only on the slot number of
 the block: We update</p><ul><li>The update state</li><li>The delegation state</li><li>The last applied slot number</li></ul><p>NOTE: The spec currently only updates the update state here; this is not good
 enough. Fortunately, updating the delegation state and slot number here
 (currently done in body processing) is at least <em>conform</em> spec, as these
 updates are conform spec. See</p><p><a href="https://github.com/intersectmbo/cardano-ledger/issues/1046">https://github.com/intersectmbo/cardano-ledger/issues/1046</a>
 <a href="https://hackage.haskell.org/package/ouroboros-network-0.16.1.0/docs/issues/1291</a></p></div></div><div class="top"><p class="src"><a id="v:validateBlock" class="def">validateBlock</a> :: <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a> <a href="Cardano-Chain-Block.html#t:ChainValidationError" title="Cardano.Chain.Block">ChainValidationError</a> m =&gt; <a href="Cardano-Chain-Genesis.html#t:Config" title="Cardano.Chain.Genesis">Config</a> -&gt; <a href="Cardano-Chain-ValidationMode.html#t:ValidationMode" title="Cardano.Chain.ValidationMode">ValidationMode</a> -&gt; <a href="Cardano-Chain-Block.html#t:ABlock" title="Cardano.Chain.Block">ABlock</a> <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="Cardano-Chain-Block.html#t:HeaderHash" title="Cardano.Chain.Block">HeaderHash</a> -&gt; <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> -&gt; m <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> <a href="#v:validateBlock" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:validateBoundary" class="def">validateBoundary</a> :: <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a> <a href="Cardano-Chain-Block.html#t:ChainValidationError" title="Cardano.Chain.Block">ChainValidationError</a> m =&gt; <a href="Cardano-Chain-Genesis.html#t:Config" title="Cardano.Chain.Genesis">Config</a> -&gt; <a href="Cardano-Chain-Block.html#t:ABoundaryBlock" title="Cardano.Chain.Block">ABoundaryBlock</a> <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> -&gt; m <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> <a href="#v:validateBoundary" class="selflink">#</a></p><div class="doc"><p>Apply a boundary block</p><p>NOTE: The <code>cvsLastSlot</code> calculation must match the one in <code>abobHdrSlotNo</code>.</p></div></div><a href="#g:3" id="g:3"><h1>Applying transactions</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:ApplyMempoolPayloadErr" class="def">ApplyMempoolPayloadErr</a> <a href="#t:ApplyMempoolPayloadErr" class="selflink">#</a></p><div class="doc"><p>Errors that arise from applying an arbitrary mempool payload</p><p>Although <code>cardano-legder</code> defines <code>MempoolPayload</code>, it does not define a
 corresponding error type. We could <code>ChainValidationError</code>, but it's too
 large, which is problematic because we actually sent encoded versions of
 these errors across the wire.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:MempoolTxErr" class="def">MempoolTxErr</a> <a href="https://hackage.haskell.org/package/cardano-ledger-binary-1.3.3.0/docs/Cardano-Ledger-Binary-Encoding.html#t:Size" title="Cardano.Ledger.Binary.Encoding">Size</a> <a href="#v:encodedListSizeExpr" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ApplyMempoolPayloadErr:Eq:6"></span> <a href="https://hackage.haskell.org/package/Cabal-syntax-3.10.3.0/docs/Distribution-Compat-Prelude.html#t:Eq" title="Distribution.Compat.Prelude">Eq</a> <a href="Cardano-Chain-Byron-API.html#t:ApplyMempoolPayloadErr" title="Cardano.Chain.Byron.API">ApplyMempoolPayloadErr</a></span> <a href="#t:ApplyMempoolPayloadErr" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ApplyMempoolPayloadErr:Eq:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Cardano-Chain-Byron-API-Mempool.html">Cardano.Chain.Byron.API.Mempool</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Cardano-Chain-Byron-API.html#t:ApplyMempoolPayloadErr" title="Cardano.Chain.Byron.API">ApplyMempoolPayloadErr</a> -&gt; <a href="Cardano-Chain-Byron-API.html#t:ApplyMempoolPayloadErr" title="Cardano.Chain.Byron.API">ApplyMempoolPayloadErr</a> -&gt; <a href="https://hackage.haskell.org/package/Cabal-syntax-3.10.3.0/docs/Distribution-Compat-Prelude.html#t:Bool" title="Distribution.Compat.Prelude">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Cardano-Chain-Byron-API.html#t:ApplyMempoolPayloadErr" title="Cardano.Chain.Byron.API">ApplyMempoolPayloadErr</a> -&gt; <a href="Cardano-Chain-Byron-API.html#t:ApplyMempoolPayloadErr" title="Cardano.Chain.Byron.API">ApplyMempoolPayloadErr</a> -&gt; <a href="https://hackage.haskell.org/package/Cabal-syntax-3.10.3.0/docs/Distribution-Compat-Prelude.html#t:Bool" title="Distribution.Compat.Prelude">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:applyMempoolPayload" class="def">applyMempoolPayload</a> :: <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Error-Class.html#t:MonadError" title="Control.Monad.Error.Class">MonadError</a> <a href="Cardano-Chain-Byron-API.html#t:ApplyMempoolPayloadErr" title="Cardano.Chain.Byron.API">ApplyMempoolPayloadErr</a> m =&gt; <a href="Cardano-Chain-ValidationMode.html#t:ValidationMode" title="Cardano.Chain.ValidationMode">ValidationMode</a> -&gt; <a href="Cardano-Chain-Genesis.html#t:Config" title="Cardano.Chain.Genesis">Config</a> -&gt; <a href="Cardano-Chain-Slotting.html#t:SlotNumber" title="Cardano.Chain.Slotting">SlotNumber</a> -&gt; <a href="Cardano-Chain-MempoolPayload.html#t:AMempoolPayload" title="Cardano.Chain.MempoolPayload">AMempoolPayload</a> <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> -&gt; m <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> <a href="#v:applyMempoolPayload" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:mempoolPayloadRecoverBytes" class="def">mempoolPayloadRecoverBytes</a> :: <a href="Cardano-Chain-MempoolPayload.html#t:AMempoolPayload" title="Cardano.Chain.MempoolPayload">AMempoolPayload</a> <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="#v:mempoolPayloadRecoverBytes" class="selflink">#</a></p><div class="doc"><p>The encoding of the mempool payload (without a <code>AMempoolPayload</code> envelope)</p></div></div><div class="top"><p class="src"><a id="v:mempoolPayloadReencode" class="def">mempoolPayloadReencode</a> :: <a href="Cardano-Chain-MempoolPayload.html#t:AMempoolPayload" title="Cardano.Chain.MempoolPayload">AMempoolPayload</a> a -&gt; <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> <a href="#v:mempoolPayloadReencode" class="selflink">#</a></p><div class="doc"><p>Re-encode the mempool payload (without any envelope)</p></div></div><a href="#g:4" id="g:4"><h1>Protocol</h1></a><div class="top"><p class="src"><a id="v:previewDelegationMap" class="def">previewDelegationMap</a> :: <a href="Cardano-Chain-Slotting.html#t:SlotNumber" title="Cardano.Chain.Slotting">SlotNumber</a> -&gt; <a href="Cardano-Chain-Block.html#t:ChainValidationState" title="Cardano.Chain.Block">ChainValidationState</a> -&gt; <a href="Cardano-Chain-Delegation.html#t:Map" title="Cardano.Chain.Delegation">Map</a> <a href="#v:previewDelegationMap" class="selflink">#</a></p><div class="doc"><p>Preview the delegation map at a slot assuming no new delegations are
 | scheduled.</p></div></div><a href="https://hackage.haskell.org/package/cardano-ledger-binary-1.3.3.0/docs/Cardano-Ledger-Binary-Decoding.html#v:reAnnotate" title="Cardano.Ledger.Binary.Decoding">reAnnotate</a></code></p></div></div><a href="#g:6" id="g:6"><h1>Headers</h1></a><div class="top"><p class="src"><a id="v:abobMatchesBody" class="def">abobMatchesBody</a> :: <a href="Cardano-Chain-Block.html#t:ABlockOrBoundaryHdr" title="Cardano.Chain.Block">ABlockOrBoundaryHdr</a> <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="Cardano-Chain-Block.html#t:ABlockOrBoundary" title="Cardano.Chain.Block">ABlockOrBoundary</a> <a href="https://hackage.haskell.org/package/bytestring-0.11.5.3/docs/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="https://hackage.haskell.org/package/Cabal-syntax-3.10.3.0/docs/Distribution-Compat-Prelude.html#t:Bool" title="Distribution.Compat.Prelude">Bool</a> <a href="#v:abobMatchesBody" class="selflink">#</a></p><div class="doc"><p>Check if a block matches its header</p><p>For EBBs, we're currently being more permissive here and not performing any
 header-body validation but only checking whether an EBB header and EBB block
 were provided. This seems to be fine as it won't cause any loss of consensus
 with the old `cardano-sl` nodes.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>