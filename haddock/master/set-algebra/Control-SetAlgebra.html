<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Control.SetAlgebra</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">set-algebra-1.1.0.3: Set Algebra</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Control.SetAlgebra</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">In addition to <code><a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map.html#v:Map" title="Data.Map">Map</a></code> and <code><a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#v:Set" title="Data.Set">Set</a></code>, types interpretable as maps and sets.</a></li><li><a href="#g:2">Classes supporting abstract constructors of Set Algebra Expressions. These show up in the types of overloaded functions.</a></li><li><a href="#g:3">Types implementing a deep embedding of set algebra expressions</a></li><li><a href="#g:4">Operators to build maps and sets,  useable as Set Algebra Expressions</a></li><li><a href="#g:5">Miscellaneous operators, including smart constructors for <code>List</code>, whose constructors are hidden.</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Operations for manipulating sets and maps using mathematicial operators. Concrete types that can be
   interpreted as sets and maps are made instances of the <code><a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a></code> class. In order to make sets and maps
   behave uniformly, an instance <code>(Basic f)</code> implies <code>f</code> is a binary type constructor. For types interpreted as
   maps, the type
  <code>(f k v)</code> means that <code>k</code> is the type of the map's key, and <code>v</code> is the type of map's value. For types
  interpreted as sets, the value is always the unit type: (). The binary GADT <code>Sett</code> links to the
  usual <code><a href="Data.html#v:Set" title="Data">Set</a></code> type. Its constructor has the following type <code>Sett :: Set k -&gt; Sett k ()</code>, programmers can
  use similar strategies to interpret other types as sets. Predefined instances of Basic include <code><a href="Data.html#v:Map" title="Data">Map</a></code>,
  <code><a href="Data.html#v:Set" title="Data">Set</a></code>, <code><a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a></code>, and <code><a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a></code>. Programmers can add <code><a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a></code> instances for their own types as well.</p><p>A typical set algebra expression (involving range restriction, (<code><a href="Control-SetAlgebra.html#v:-9655-" title="Control.SetAlgebra">&#9655;</a></code>), here) looks like <code>(eval (x &#9655; y))</code>.
  Where <code>x</code> and <code>y</code> are program variables or expressions, the operator (<code><a href="Control-SetAlgebra.html#v:-9655-" title="Control.SetAlgebra">&#9655;</a></code>) builds an <code><a href="Control-SetAlgebra.html#t:Exp" title="Control.SetAlgebra">Exp</a></code> tree, and
 <code><a href="Control-SetAlgebra.html#v:eval" title="Control.SetAlgebra">eval</a></code> simplifys the tree, and then evaluates the simplfied tree to get the result.
 Here is the actual type of the range restrict operator.</p><pre>(&#9655;) :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) =&gt; s1 -&gt; s2 -&gt; Exp (f k v)
</pre><p>As the type indicates, in order to support simplifcation and evaluation the types of the
 operands to (<code><a href="Control-SetAlgebra.html#v:-9655-" title="Control.SetAlgebra">&#9655;</a></code>) must be instances of several classes. Possible classes include <code><a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a></code>,
 <code><a href="Control-SetAlgebra.html#t:HasExp" title="Control.SetAlgebra">HasExp</a></code>, <code><a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a></code>, and <code><a href="Control-SetAlgebra.html#t:Embed" title="Control.SetAlgebra">Embed</a></code>.</p><ol><li value="1"><code>(Basic f)</code> meaning <code>(f k v)</code> must be interpreted as a map or set, with two type parameters <code>k</code> and <code>v</code>.</li><li value="2"><code>(HasExp t (f k v))</code>  meaning a value of type <code>t</code> can be lifted to an expression of type <code>(Exp (f k v))</code>, where <code>(Basic f)</code>.</li><li value="3"><code>(Iter f)</code> meaning the <code>Basic</code> type constructor <code>f</code> supports certain (usually fast) operations, that can be combined.</li><li value="4"><code>(Embed concrete f)</code> meaning the types <code>concrete</code> and <code>(f k v)</code> form an isomorphism.</li></ol><p>Available operands to create set algebra expressions are <code><a href="Control-SetAlgebra.html#v:dom" title="Control.SetAlgebra">dom</a></code>, <code><a href="Control-SetAlgebra.html#v:rng" title="Control.SetAlgebra">rng</a></code>, <code><a href="Control-SetAlgebra.html#v:dexclude" title="Control.SetAlgebra">dexclude</a></code>,  <code><a href="Control-SetAlgebra.html#v:-8938-" title="Control.SetAlgebra">(&#8938;)</a></code>, <code><a href="Control-SetAlgebra.html#v:drestrict" title="Control.SetAlgebra">drestrict</a></code>, <code><a href="Control-SetAlgebra.html#v:-9665-" title="Control.SetAlgebra">(&#9665;)</a></code>,
 <code><a href="Control-SetAlgebra.html#v:rexclude" title="Control.SetAlgebra">rexclude</a></code>, <code><a href="Control-SetAlgebra.html#v:-8939-" title="Control.SetAlgebra">(&#8939;)</a></code>, <code><a href="Control-SetAlgebra.html#v:rrestrict" title="Control.SetAlgebra">rrestrict</a></code>,  <code><a href="Control-SetAlgebra.html#v:-9655-" title="Control.SetAlgebra">(&#9655;)</a></code>,
 <code><a href="Control-SetAlgebra.html#v:unionright" title="Control.SetAlgebra">unionright</a></code>,  <code><a href="Control-SetAlgebra.html#v:-10755-" title="Control.SetAlgebra">(&#10755;)</a></code>, <code><a href="Control-SetAlgebra.html#v:unionleft" title="Control.SetAlgebra">unionleft</a></code>,<code><a href="Control-SetAlgebra.html#v:-8746-" title="Control.SetAlgebra">(&#8746;)</a></code>, <code><a href="Control-SetAlgebra.html#v:unionplus" title="Control.SetAlgebra">unionplus</a></code>,  <code><a href="Control-SetAlgebra.html#v:-8746--43-" title="Control.SetAlgebra">(&#8746;+)</a></code>,<code><a href="Control-SetAlgebra.html#v:singleton" title="Control.SetAlgebra">singleton</a></code>, <code><a href="Control-SetAlgebra.html#v:setSingleton" title="Control.SetAlgebra">setSingleton</a></code>,
 <code><a href="Control-SetAlgebra.html#v:intersect" title="Control.SetAlgebra">intersect</a></code>, <code><a href="Control-SetAlgebra.html#v:-8745-" title="Control.SetAlgebra">(&#8745;)</a></code>,  <code><a href="Control-SetAlgebra.html#v:subset" title="Control.SetAlgebra">subset</a></code>,  <code><a href="Control-SetAlgebra.html#v:-8838-" title="Control.SetAlgebra">(&#8838;)</a></code>, <code><a href="Control-SetAlgebra.html#v:keyeq" title="Control.SetAlgebra">keyeq</a></code>,  <code><a href="Control-SetAlgebra.html#v:-8781-" title="Control.SetAlgebra">(&#8781;)</a></code>,
 <code><a href="Control-SetAlgebra.html#v:-8712-" title="Control.SetAlgebra">(&#8712;)</a></code>, <code><a href="Control-SetAlgebra.html#v:-8713-" title="Control.SetAlgebra">(&#8713;)</a></code>,  <code><a href="Control-SetAlgebra.html#v:setdiff" title="Control.SetAlgebra">setdiff</a></code>, <code><a href="Control-SetAlgebra.html#v:-10134-" title="Control.SetAlgebra">(&#10134;)</a></code> .</p><p>The key abstraction that makes set algebra work is the self typed GADT: <code>(Exp t)</code>, that defines a tree that
 represents a deep embedding of all set algebra expressions representing maps or sets of type <code>t</code>.
 <code>Exp</code> is a typed symbolic representation of queries we may ask. It allows us to introspect a query.
 The strategy is to</p><ol><li value="1">Define Exp so all queries can be represented.</li><li value="2">Define smart constructors that &quot;parse&quot; the surface syntax, and build a typed Exp</li><li value="3">Write an evaluate function:  eval:: Exp t -&gt; t</li><li value="4">&quot;eval&quot; can introspect the code and apply efficient domain and type specific translations</li><li value="5">Use the (Iter f) class to evaluate some Exp that can benefit from its efficient nature.</li></ol><p>Basically, if the compiler can infer concrete type for the operands of <a href="Control-SetAlgebra.html#setoperators#">operators</a> then
 all the class instances are automatically solved. If you get an error involving a class, then it is most
 probably the case that the type of the operands cannot be properly inferred.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="https://hackage.haskell.org/package/cardano-data-1.2.2.0/docs/Data-CanonicalMaps.html#t:Map" title="Data.CanonicalMaps">Map</a> k v2 -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:setdiff">setdiff</a> :: (<a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> f, <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> g, <a href="Control-SetAlgebra.html#t:HasExp" title="Control.SetAlgebra">HasExp</a> s1 (f k v), <a href="Control-SetAlgebra.html#t:HasExp" title="Control.SetAlgebra">HasExp</a> s2 (g k u)) =&gt; s1 -&gt; s2 -&gt; <a href="Control-SetAlgebra.html#t:Exp" title="Control.SetAlgebra">Exp</a> (f k v)</li><li class="src short"><a href="#v:materialize">materialize</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> f k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, v) -&gt; f k v</li><li class="src short"><a href="#v:fromList">fromList</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> f k v -&gt; (v -&gt; v -&gt; v) -&gt; [(k, v)] -&gt; f k v</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>In addition to <code><a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map.html#v:Map" title="Data.Map">Map</a></code> and <code><a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#v:Set" title="Data.Set">Set</a></code>, types interpretable as maps and sets.</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:List" class="def">List</a> k v <a href="#t:List" class="selflink">#</a></p><div class="doc"><p>Maps stored as lists. Sorted [(key,value)] pairs, with no duplicate keys.
 The constructor for List is hidden, since it requires some invariants. Use <code><a href="Control-Iterate-BaseTypes.html#v:fromPairs" title="Control.Iterate.BaseTypes">fromPairs</a></code> to build an initial List.</p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:List">Instances</h4><details id="i:List" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:List:Basic:1"></span> <a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a> <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a></span> <a href="#t:List" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:List:Basic:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:addpair">addpair</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; v -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v <a href="#v:addpair" class="selflink">#</a></p><p class="src"><a href="#v:addkv">addkv</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k, v) -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; (v -&gt; v -&gt; v) -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v <a href="#v:addkv" class="selflink">#</a></p><p class="src"><a href="#v:removekey">removekey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v <a href="#v:removekey" class="selflink">#</a></p><p class="src"><a href="#v:domain">domain</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> k <a href="#v:domain" class="selflink">#</a></p><p class="src"><a href="#v:range">range</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v =&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> v <a href="#v:range" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:List:Iter:2"></span> <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a></span> <a href="#t:List" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:List:Iter:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:nxt">nxt</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> a b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (a, b, <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> a b) <a href="#v:nxt" class="selflink">#</a></p><p class="src"><a href="#v:lub">lub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, b, <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k b) <a href="#v:lub" class="selflink">#</a></p><p class="src"><a href="#v:hasNxt">hasNxt</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> a b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b, <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> a b) <a href="#v:hasNxt" class="selflink">#</a></p><p class="src"><a href="#v:hasLub">hasLub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, b, <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k b) <a href="#v:hasLub" class="selflink">#</a></p><p class="src"><a href="#v:haskey">haskey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> key b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:haskey" class="selflink">#</a></p><p class="src"><a href="#v:isnull">isnull</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:isnull" class="selflink">#</a></p><p class="src"><a href="#v:lookup">lookup</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> key rng -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> rng <a href="#v:lookup" class="selflink">#</a></p><p class="src"><a href="#v:element">element</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> () <a href="#v:element" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:List:Embed:3"></span> <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:Embed" title="Control.SetAlgebra">Embed</a> [(k, v)] (<a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v)</span> <a href="#t:List" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:List:Embed:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toBase">toBase</a> :: [(k, v)] -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v <a href="#v:toBase" class="selflink">#</a></p><p class="src"><a href="#v:fromBase">fromBase</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; [(k, v)] <a href="#v:fromBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:List:HasExp:4"></span> <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:HasExp" title="Control.SetAlgebra">HasExp</a> [(k, v)] (<a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v)</span> <a href="#t:HasExp" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:List:HasExp:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-Exp.html">Control.Iterate.Exp</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toExp">toExp</a> :: [(k, v)] -&gt; <a href="Control-SetAlgebra.html#t:Exp" title="Control.SetAlgebra">Exp</a> (<a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v) <a href="#v:toExp" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:List:Show:5"></span> (<a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> k, <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> v) =&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v)</span> <a href="#t:List" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:List:Show:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v] -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:List:Eq:6"></span> (<a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> k, <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> v) =&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v)</span> <a href="#t:List" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:List:Eq:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Single" class="def">Single</a> k v <span class="keyword">where</span> <a href="#t:Single" class="selflink">#</a></p><div class="doc"><p>Maps and sets with zero or a single pair. Iteration is trivial. Succeeds at most once.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Single" class="def">Single</a> :: k -&gt; v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Fail" class="def">Fail</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SetSingle" class="def">SetSingle</a> :: k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Single">Instances</h4><details id="i:Single" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Single:Basic:1"></span> <a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a> <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a></span> <a href="#t:Single" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Single:Basic:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:addpair">addpair</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:addpair" class="selflink">#</a></p><p class="src"><a href="#v:addkv">addkv</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k, v) -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; (v -&gt; v -&gt; v) -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:addkv" class="selflink">#</a></p><p class="src"><a href="#v:removekey">removekey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:removekey" class="selflink">#</a></p><p class="src"><a href="#v:domain">domain</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> k <a href="#v:domain" class="selflink">#</a></p><p class="src"><a href="#v:range">range</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v =&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> v <a href="#v:range" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Single:Iter:2"></span> <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a></span> <a href="#t:Single" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Single:Iter:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:nxt">nxt</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> a b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (a, b, <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> a b) <a href="#v:nxt" class="selflink">#</a></p><p class="src"><a href="#v:lub">lub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, b, <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k b) <a href="#v:lub" class="selflink">#</a></p><p class="src"><a href="#v:hasNxt">hasNxt</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> a b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b, <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> a b) <a href="#v:hasNxt" class="selflink">#</a></p><p class="src"><a href="#v:hasLub">hasLub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, b, <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k b) <a href="#v:hasLub" class="selflink">#</a></p><p class="src"><a href="#v:haskey">haskey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> key b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:haskey" class="selflink">#</a></p><p class="src"><a href="#v:isnull">isnull</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:isnull" class="selflink">#</a></p><p class="src"><a href="#v:lookup">lookup</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> key rng -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> rng <a href="#v:lookup" class="selflink">#</a></p><p class="src"><a href="#v:element">element</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> () <a href="#v:element" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Single:Show:3"></span> (<a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> k, <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> v) =&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v)</span> <a href="#t:Single" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Single:Show:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v] -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Single:Eq:4"></span> (<a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> k, <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> v) =&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v)</span> <a href="#t:Single" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Single:Eq:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Single:HasQuery:5"></span> <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-Iterate-Exp.html#t:HasQuery" title="Control.Iterate.Exp">HasQuery</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v) k v</span> <a href="#t:HasQuery" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Single:HasQuery:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-Exp.html">Control.Iterate.Exp</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:query">query</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> k v <a href="#v:query" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Single:Embed:6"></span> <a href="Control-SetAlgebra.html#t:Embed" title="Control.SetAlgebra">Embed</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v) (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v)</span> <a href="#t:Single" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Single:Embed:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toBase">toBase</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:toBase" class="selflink">#</a></p><p class="src"><a href="#v:fromBase">fromBase</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:fromBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Single:HasExp:7"></span> <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:HasExp" title="Control.SetAlgebra">HasExp</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v) (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v)</span> <a href="#t:HasExp" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Single:HasExp:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-Exp.html">Control.Iterate.Exp</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toExp">toExp</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Exp" title="Control.SetAlgebra">Exp</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v) <a href="#v:toExp" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1>Classes supporting abstract constructors of Set Algebra Expressions. These show up in the types of overloaded functions.</h1></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Basic" class="def">Basic</a> f <span class="keyword">where</span> <a href="#t:Basic" class="selflink">#</a></p><div class="doc"><p>In order to build typed <code>Exp</code> (which are a typed deep embedding) of map and set operations, we need to know
 what kind of basic types can be used this way. Every Basic type has a few operations
 for creating one from a list, for adding and removing key-value pairs, looking up a value given a key.
 Instances of this algebra are functional in that every key has exactly one value associated with it.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="https://hackage.haskell.org/package/cardano-data-1.2.2.0/docs/Data-CanonicalMaps.html#t:Map" title="Data.CanonicalMaps">Map</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> v <a href="#v:range" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Basic:Basic:2"></span> <a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a> <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a></span> <a href="#t:Basic" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Basic:Basic:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:addpair">addpair</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; v -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v <a href="#v:addpair" class="selflink">#</a></p><p class="src"><a href="#v:addkv">addkv</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k, v) -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; (v -&gt; v -&gt; v) -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v <a href="#v:addkv" class="selflink">#</a></p><p class="src"><a href="#v:removekey">removekey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v <a href="#v:removekey" class="selflink">#</a></p><p class="src"><a href="#v:domain">domain</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> k <a href="#v:domain" class="selflink">#</a></p><p class="src"><a href="#v:range">range</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v =&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> v <a href="#v:range" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Basic:Basic:3"></span> <a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a> <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a></span> <a href="#t:Basic" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Basic:Basic:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:addpair">addpair</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; v -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v <a href="#v:addpair" class="selflink">#</a></p><p class="src"><a href="#v:addkv">addkv</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k, v) -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v -&gt; (v -&gt; v -&gt; v) -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v <a href="#v:addkv" class="selflink">#</a></p><p class="src"><a href="#v:removekey">removekey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v <a href="#v:removekey" class="selflink">#</a></p><p class="src"><a href="#v:domain">domain</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> k <a href="#v:domain" class="selflink">#</a></p><p class="src"><a href="#v:range">range</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v =&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> v <a href="#v:range" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Basic:Basic:4"></span> <a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a> <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a></span> <a href="#t:Basic" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Basic:Basic:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:addpair">addpair</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:addpair" class="selflink">#</a></p><p class="src"><a href="#v:addkv">addkv</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; (k, v) -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; (v -&gt; v -&gt; v) -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:addkv" class="selflink">#</a></p><p class="src"><a href="#v:removekey">removekey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:removekey" class="selflink">#</a></p><p class="src"><a href="#v:domain">domain</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> k <a href="#v:domain" class="selflink">#</a></p><p class="src"><a href="#v:range">range</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v =&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> v <a href="#v:range" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Iter" class="def">Iter</a> f <span class="keyword">where</span> <a href="#t:Iter" class="selflink">#</a></p><div class="doc"><p>The Set algebra include types that encode finite sets and maps of some type. They
 have a finite domain, and for each domain element they pair a single range
 element (unit for sets). We are interested in those finite maps that can iterate their
 pairs in ascending domain order. The operations are: <code><a href="Control-SetAlgebra.html#v:nxt" title="Control.SetAlgebra">nxt</a></code> and <code><a href="Control-SetAlgebra.html#v:lub" title="Control.SetAlgebra">lub</a></code> .
 lub can skip over many items in sub-linear time, it can make things really fast.
 Many finite maps can support a support lub operation in sub-linear time. Some examples:
 Balanced binary trees, Arrays (using binary search), Tries, etc. There are basic and compound
 Iter instances. Compound types include components with types that have Iter instances.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Control-SetAlgebra.html#v:nxt" title="Control.SetAlgebra">nxt</a>, <a href="Control-SetAlgebra.html#v:lub" title="Control.SetAlgebra">lub</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:nxt" class="def">nxt</a> :: f a b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (a, b, f a b) <a href="#v:nxt" class="selflink">#</a></p><p class="src"><a id="v:lub" class="def">lub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; f k b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, b, f k b) <a href="#v:lub" class="selflink">#</a></p><p class="src"><a id="v:hasNxt" class="def">hasNxt</a> :: f a b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b, f a b) <a href="#v:hasNxt" class="selflink">#</a></p><div class="doc"><p>The next few methods can all be defined via nxt and lub, but for base types there often exist
 much more efficent means, so the default definitions should be overwritten for such basic types.
 For compound types with Guards, these are often the only way to define them.</p></div><p class="src"><a id="v:hasLub" class="def">hasLub</a> :: <a href="https://hackage.haskell.org/package/cardano-data-1.2.2.0/docs/Data-CanonicalMaps.html#t:Map" title="Data.CanonicalMaps">Map</a> k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> () <a href="#v:element" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Iter:Iter:2"></span> <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a></span> <a href="#t:Iter" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Iter:Iter:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:nxt">nxt</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> a b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (a, b, <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> a b) <a href="#v:nxt" class="selflink">#</a></p><p class="src"><a href="#v:lub">lub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, b, <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k b) <a href="#v:lub" class="selflink">#</a></p><p class="src"><a href="#v:hasNxt">hasNxt</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> a b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b, <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> a b) <a href="#v:hasNxt" class="selflink">#</a></p><p class="src"><a href="#v:hasLub">hasLub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, b, <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k b) <a href="#v:hasLub" class="selflink">#</a></p><p class="src"><a href="#v:haskey">haskey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> key b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:haskey" class="selflink">#</a></p><p class="src"><a href="#v:isnull">isnull</a> :: <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:isnull" class="selflink">#</a></p><p class="src"><a href="#v:lookup">lookup</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> key rng -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> rng <a href="#v:lookup" class="selflink">#</a></p><p class="src"><a href="#v:element">element</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> () <a href="#v:element" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Iter:Iter:3"></span> <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a></span> <a href="#t:Iter" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Iter:Iter:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:nxt">nxt</a> :: <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> a b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (a, b, <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> a b) <a href="#v:nxt" class="selflink">#</a></p><p class="src"><a href="#v:lub">lub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, b, <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k b) <a href="#v:lub" class="selflink">#</a></p><p class="src"><a href="#v:hasNxt">hasNxt</a> :: <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> a b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b, <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> a b) <a href="#v:hasNxt" class="selflink">#</a></p><p class="src"><a href="#v:hasLub">hasLub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, b, <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k b) <a href="#v:hasLub" class="selflink">#</a></p><p class="src"><a href="#v:haskey">haskey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> key b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:haskey" class="selflink">#</a></p><p class="src"><a href="#v:isnull">isnull</a> :: <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:isnull" class="selflink">#</a></p><p class="src"><a href="#v:lookup">lookup</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> key rng -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> rng <a href="#v:lookup" class="selflink">#</a></p><p class="src"><a href="#v:element">element</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> () <a href="#v:element" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Iter:Iter:4"></span> <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a></span> <a href="#t:Iter" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Iter:Iter:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:nxt">nxt</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> a b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (a, b, <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> a b) <a href="#v:nxt" class="selflink">#</a></p><p class="src"><a href="#v:lub">lub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, b, <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k b) <a href="#v:lub" class="selflink">#</a></p><p class="src"><a href="#v:hasNxt">hasNxt</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> a b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b, <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> a b) <a href="#v:hasNxt" class="selflink">#</a></p><p class="src"><a href="#v:hasLub">hasLub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, b, <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k b) <a href="#v:hasLub" class="selflink">#</a></p><p class="src"><a href="#v:haskey">haskey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> key b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:haskey" class="selflink">#</a></p><p class="src"><a href="#v:isnull">isnull</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:isnull" class="selflink">#</a></p><p class="src"><a href="#v:lookup">lookup</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> key rng -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> rng <a href="#v:lookup" class="selflink">#</a></p><p class="src"><a href="#v:element">element</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> () <a href="#v:element" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Iter:Iter:5"></span> <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a></span> <a href="#t:Iter" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Iter:Iter:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-Exp.html">Control.Iterate.Exp</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:nxt">nxt</a> :: <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> a b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (a, b, <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> a b) <a href="#v:nxt" class="selflink">#</a></p><p class="src"><a href="#v:lub">lub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> k b -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, b, <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> k b) <a href="#v:lub" class="selflink">#</a></p><p class="src"><a href="#v:hasNxt">hasNxt</a> :: <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> a b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b, <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> a b) <a href="#v:hasNxt" class="selflink">#</a></p><p class="src"><a href="#v:hasLub">hasLub</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> k b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (k, b, <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> k b) <a href="#v:hasLub" class="selflink">#</a></p><p class="src"><a href="#v:haskey">haskey</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> key b -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:haskey" class="selflink">#</a></p><p class="src"><a href="#v:isnull">isnull</a> :: <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:isnull" class="selflink">#</a></p><p class="src"><a href="#v:lookup">lookup</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> key =&gt; key -&gt; <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> key rng -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> rng <a href="#v:lookup" class="selflink">#</a></p><p class="src"><a href="#v:element">element</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; k -&gt; <a href="Control-Iterate-Exp.html#t:Query" title="Control.Iterate.Exp">Query</a> k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> () <a href="#v:element" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:HasExp" class="def">HasExp</a> s t | s -&gt; t <span class="keyword">where</span> <a href="#t:HasExp" class="selflink">#</a></p><div class="doc"><p>Basic types are those that can be tranformed into Exp.
 The HasExp class, encodes how to lift a Basic type into an Exp.
 The function <code><a href="Control-SetAlgebra.html#v:toExp" title="Control.SetAlgebra">toExp</a></code> will build a typed Exp for that Basic type.
 This will be really usefull in the smart constructors.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:toExp" class="def">toExp</a> :: s -&gt; <a href="https://hackage.haskell.org/package/cardano-data-1.2.2.0/docs/Data-CanonicalMaps.html#t:Map" title="Data.CanonicalMaps">Map</a> k v) <a href="#v:toExp" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:HasExp:HasExp:5"></span> <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:HasExp" title="Control.SetAlgebra">HasExp</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v) (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v)</span> <a href="#t:HasExp" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:HasExp:HasExp:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-Exp.html">Control.Iterate.Exp</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toExp">toExp</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Exp" title="Control.SetAlgebra">Exp</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v) <a href="#v:toExp" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Embed" class="def">Embed</a> concrete base | concrete -&gt; base <span class="keyword">where</span> <a href="#t:Embed" class="selflink">#</a></p><div class="doc"><p>Every iterable type type forms an isomorphism with some Base type. For most
 Base types the isomorphism is the identity in both directions, but for some,
 like List and Sett, the embeddings are not the trivial identities because the
 concrete types are not binary type constructors. The Embed class also allows
 us to add <code>newtypes</code> which encode some Base type to the system.</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:toBase" class="def">toBase</a> :: concrete -&gt; base <a href="https://hackage.haskell.org/package/cardano-data-1.2.2.0/docs/Data-CanonicalMaps.html#t:Map" title="Data.CanonicalMaps">Map</a> k v <a href="#v:fromBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Embed:Embed:5"></span> <a href="Control-SetAlgebra.html#t:Embed" title="Control.SetAlgebra">Embed</a> (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v) (<a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v)</span> <a href="#t:Embed" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Embed:Embed:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toBase">toBase</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:toBase" class="selflink">#</a></p><p class="src"><a href="#v:fromBase">fromBase</a> :: <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v -&gt; <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v <a href="#v:fromBase" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:3" id="g:3"><h1>Types implementing a deep embedding of set algebra expressions</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:BaseRep" class="def">BaseRep</a> f k v <span class="keyword">where</span> <a href="#t:BaseRep" class="selflink">#</a></p><div class="doc"><p>BaseRep witnesses Basic types. I.e. those types that are instances of both Basic and Iter.
   Pattern matching against a constructor of type BaseRep, determines which base type. For example
   data Tag f k v = Tag (BaseRep f k v) (f k v)
   case Tag MapR x -&gt;  -- here we know x :: Map.Map k v</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:MapR" class="def">MapR</a> :: <a href="https://hackage.haskell.org/package/cardano-data-1.2.2.0/docs/Data-CanonicalMaps.html#t:Map" title="Data.CanonicalMaps">Map</a> k v</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SetR" class="def">SetR</a> :: <a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a> <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> =&gt; <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> <a href="Control-Iterate-BaseTypes.html#t:Sett" title="Control.Iterate.BaseTypes">Sett</a> k ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:ListR" class="def">ListR</a> :: <a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a> <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> =&gt; <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> <a href="Control-SetAlgebra.html#t:List" title="Control.SetAlgebra">List</a> k v</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:SingleR" class="def">SingleR</a> :: <a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a> <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> =&gt; <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> <a href="Control-SetAlgebra.html#t:Single" title="Control.SetAlgebra">Single</a> k v</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:BaseRep">Instances</h4><details id="i:BaseRep" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:BaseRep:Show:1"></span> <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> f k v)</span> <a href="#t:BaseRep" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:BaseRep:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Control-Iterate-BaseTypes.html">Control.Iterate.BaseTypes</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> f k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> f k v -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> f k v] -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Exp" class="def">Exp</a> t <span class="keyword">where</span> <a href="#t:Exp" class="selflink">#</a></p><div class="doc"><p>The self typed GADT: Exp, that encodes the shape of Set expressions. A deep embedding.
 Exp is a typed Symbolic representation of queries we may ask. It allows us to introspect a query
 The strategy is to</p><ol><li value="1">Define Exp so all queries can be represented.</li><li value="2">Define smart constructors that &quot;parse&quot; the surface syntax, and build a typed Exp</li><li value="3">Write an evaluate function:  eval:: Exp t -&gt; t</li><li value="4">&quot;eval&quot; can introspect the code and apply efficient domain and type specific translations</li><li value="5">Use the (Iter f) class to evaluate some Exp that can benefit from its efficient nature.</li></ol></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Base" class="def">Base</a> :: (<a href="https://hackage.haskell.org/package/cardano-data-1.2.2.0/docs/Data-CanonicalMaps.html#t:Map" title="Data.CanonicalMaps">Map</a> k v2 -&gt; <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:keysEqual" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:setdiff" class="def">setdiff</a> :: (<a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k, <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> f, <a href="Control-SetAlgebra.html#t:Iter" title="Control.SetAlgebra">Iter</a> g, <a href="Control-SetAlgebra.html#t:HasExp" title="Control.SetAlgebra">HasExp</a> s1 (f k v), <a href="Control-SetAlgebra.html#t:HasExp" title="Control.SetAlgebra">HasExp</a> s2 (g k u)) =&gt; s1 -&gt; s2 -&gt; <a href="Control-SetAlgebra.html#t:Exp" title="Control.SetAlgebra">Exp</a> (f k v) <a href="#v:setdiff" class="selflink">#</a></p><div class="doc"><p><code>(x &#10134; y)</code> Everything in <code>x</code> except for those pairs in <code>x</code> where the domain of <code>x</code> is an element of the domain of <code>y</code>.</p></div></div><a href="#g:5" id="g:5"><h1>Miscellaneous operators, including smart constructors for <code>List</code>, whose constructors are hidden.</h1></a><div class="top"><p class="src"><a id="v:materialize" class="def">materialize</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> f k v -&gt; <a href="Control-Iterate-Collect.html#t:Collect" title="Control.Iterate.Collect">Collect</a> (k, v) -&gt; f k v <a href="#v:materialize" class="selflink">#</a></p><div class="doc"><p>A witness (BaseRep) can be used to materialize a (Collect k v) into the type witnessed by the BaseRep.
 Recall a (Collect k v) has no intrinsic type (it is just an ABSTRACT sequence of tuples), so
 the witness describes how to turn them into the chosen datatype. Note that materialize is meant
 to be applied to a collection built by iterating over a Query. This produces the keys in
 ascending order, with no duplicate keys. So we do not need to specify how to merge duplicate values.</p></div></div><div class="top"><p class="src"><a id="v:fromList" class="def">fromList</a> :: <a href="https://hackage.haskell.org/package/base-4.18.2.1/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k =&gt; <a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a> f k v -&gt; (v -&gt; v -&gt; v) -&gt; [(k, v)] -&gt; f k v <a href="#v:fromList" class="selflink">#</a></p><div class="doc"><p>Turn a list of pairs into any <code><a href="Control-SetAlgebra.html#t:Basic" title="Control.SetAlgebra">Basic</a></code> type. The first argument is a <code><a href="Control-SetAlgebra.html#t:BaseRep" title="Control.SetAlgebra">BaseRep</a></code> which
   chooses what Base type to construct.
 The combine function comb = (\ earlier later -&gt; later) will let values
 later in the list override ones earlier in the list, and comb =
 (\ earlier later -&gt; earlier) will keep the value that appears first in the list</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>