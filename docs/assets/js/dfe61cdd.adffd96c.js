"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1632],{6151:(i,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var n=t(4848),s=t(8453);const r={sidebar_position:10},o="Writing basic minting policies",c={id:"working-with-scripts/writing-basic-minting-policies",title:"Writing basic minting policies",description:"Minting policy scripts are the programs that can be used to control the minting of new assets on the chain.",source:"@site/docs/working-with-scripts/writing-basic-minting-policies.md",sourceDirName:"working-with-scripts",slug:"/working-with-scripts/writing-basic-minting-policies",permalink:"/docs/working-with-scripts/writing-basic-minting-policies",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/working-with-scripts/writing-basic-minting-policies.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Writing basic validator scripts",permalink:"/docs/working-with-scripts/writing-basic-validator-scripts"},next:{title:"Exporting scripts, datums and redeemers",permalink:"/docs/working-with-scripts/exporting-scripts-datums-redeemers"}},a={},l=[{value:"Minting policy arguments",id:"minting-policy-arguments",level:2},{value:"Plutus script context versions",id:"plutus-script-context-versions",level:2},{value:"Writing minting policies",id:"writing-minting-policies",level:2},{value:"Other policy examples",id:"other-policy-examples",level:2}];function h(i){const e={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...i.components},{LiteralInclude:t}=e;return t||function(i,e){throw new Error("Expected "+(e?"component":"object")+" `"+i+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteralInclude",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:"writing-basic-minting-policies",children:"Writing basic minting policies"}),"\n",(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:"/docs/reference/glossary#minting-policy-script",children:"Minting policy scripts"})," are the programs that can be used to control the minting of new assets on the chain.\nMinting policy scripts are much like ",(0,n.jsx)(e.a,{href:"/docs/reference/glossary#validator-script",children:"validator scripts"}),", and they are written similarly, so please review ",(0,n.jsx)(e.a,{href:"/docs/working-with-scripts/writing-basic-validator-scripts",children:"Writing basic validator scripts"})," before reading this topic."]}),"\n",(0,n.jsx)(e.h2,{id:"minting-policy-arguments",children:"Minting policy arguments"}),"\n",(0,n.jsx)(e.p,{children:"Minting policies, like validators, receive some information from the validating node:"}),"\n",(0,n.jsxs)(e.ul,{children:["\n",(0,n.jsxs)(e.li,{children:["The ",(0,n.jsx)(e.a,{href:"/docs/reference/glossary#redeemer",children:"redeemer"}),", which is some script-specific data specified by the party performing the minting."]}),"\n",(0,n.jsxs)(e.li,{children:["The ",(0,n.jsx)(e.a,{href:"/docs/reference/glossary#script-context",children:"script context"}),", which contains a representation of the spending transaction, as well as the hash of the minting policy which is currently being run."]}),"\n"]}),"\n",(0,n.jsxs)(e.p,{children:["The minting policy is a function which receives these two inputs as ",(0,n.jsx)(e.em,{children:"arguments"}),". The validating node is responsible for passing them in and running the minting policy.\nAs with validator scripts, the arguments are passed encoded as ",(0,n.jsx)(e.code,{children:"PlutusCore.Data.Data"}),"."]}),"\n",(0,n.jsx)(e.h2,{id:"plutus-script-context-versions",children:"Plutus script context versions"}),"\n",(0,n.jsxs)(e.p,{children:["Minting policies have access to the ",(0,n.jsx)(e.a,{href:"/docs/reference/glossary#script-context",children:"script context"})," as their second argument.\nEach version of Plutus minting policy scripts are differentiated only by their ",(0,n.jsx)(e.code,{children:"ScriptContext"})," argument."]}),"\n",(0,n.jsxs)(e.blockquote,{children:["\n",(0,n.jsxs)(e.p,{children:["See this example from the file ",(0,n.jsx)(e.code,{children:"MustSpendScriptOutput.hs"})," (lines 340 to 422) showing code addressing ",(0,n.jsx)(e.a,{href:"https://github.com/IntersectMBO/plutus-apps/blob/05e394fb6188abbbe827ff8a51a24541a6386422/plutus-contract/test/Spec/TxConstraints/MustSpendScriptOutput.hs#L340-L422",children:"Versioned Policies for both Plutus V1 and Plutus V2"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(e.p,{children:["Minting policies tend to be particularly interested in the ",(0,n.jsx)(e.code,{children:"mint"})," field, since the point of a minting policy is to control which tokens are minted."]}),"\n",(0,n.jsxs)(e.p,{children:["It is also important for a minting policy to look at the tokens in the ",(0,n.jsx)(e.code,{children:"mint"})," field that use its own currency symbol i.e. policy hash.\nNote that checking only a specific token name is usually not correct.\nThe minting policy must check for correct minting (or lack there of) of all token names under its currency symbol.\nThis requires the policy to refer to its own hash\u2014fortunately this is provided for us in the script context of a minting policy."]}),"\n",(0,n.jsx)(e.h2,{id:"writing-minting-policies",children:"Writing minting policies"}),"\n",(0,n.jsx)(e.p,{children:"Here is an example that puts this together to make a simple policy that allows anyone to mint the token so long as they do it one token at a time.\nTo begin with, we'll write a version that works with structured types."}),"\n",(0,n.jsx)(t,{file:"BasicPolicies.hs",language:"haskell",title:"Example simple minting policy",start:"-- BLOCK1",end:"-- BLOCK2"}),"\n",(0,n.jsxs)(e.p,{children:["However, scripts are actually given their arguments as type ",(0,n.jsx)(e.code,{children:"Data"}),", and must signal failure with ",(0,n.jsx)(e.code,{children:"error"}),", so we need to wrap up our typed version to use it on-chain."]}),"\n",(0,n.jsx)(t,{file:"BasicPolicies.hs",language:"haskell",title:"Example of wrapping a typed version",start:"-- BLOCK2",end:"-- BLOCK3"}),"\n",(0,n.jsx)(e.h2,{id:"other-policy-examples",children:"Other policy examples"}),"\n",(0,n.jsx)(e.p,{children:"Probably the simplest useful policy is one that requires a specific key to have signed the transaction in order to do any minting.\nThis gives the key holder total control over the supply, but this is often sufficient for asset types where there is a centralized authority."}),"\n",(0,n.jsx)(t,{file:"BasicPolicies.hs",language:"haskell",title:"Policy example",start:"-- BLOCK3",end:"-- BLOCK4"}),"\n",(0,n.jsxs)(e.blockquote,{children:["\n",(0,n.jsxs)(e.p,{children:["\ud83d\udccc"," ",(0,n.jsx)(e.strong,{children:"NOTE"})]}),"\n",(0,n.jsx)(e.p,{children:"We don't need to check that this transaction actually mints any of our asset type: the ledger rules ensure that the minting policy will only be run if some of that asset is being minted."}),"\n"]})]})}function p(i={}){const{wrapper:e}={...(0,s.R)(),...i.components};return e?(0,n.jsx)(e,{...i,children:(0,n.jsx)(h,{...i})}):h(i)}},8453:(i,e,t)=>{t.d(e,{R:()=>o,x:()=>c});var n=t(6540);const s={},r=n.createContext(s);function o(i){const e=n.useContext(r);return n.useMemo((function(){return"function"==typeof i?i(e):{...e,...i}}),[e,i])}function c(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(s):i.components||s:o(i.components),n.createElement(r.Provider,{value:e},i.children)}}}]);